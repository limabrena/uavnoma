<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pa-uav-noma API documentation</title>
<meta name="description" content="Numerical Simulation of Power allocation in UAV-NOMA System â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pa-uav-noma</code></h1>
</header>
<section id="section-intro">
<p>Numerical Simulation of Power allocation in UAV-NOMA System.</p>
<p>A Python 3.9 implementation of a model of wireless communication
system between an area base station and two users.
Initially, power allocation is employed manually.</p>
<hr>
<h3 id="how-can-use-this-application">How can use this application?</h3>
<ul>
<li>
<p>Download:</p>
<p>Cloning the repository via terminal:</p>
<pre><code> $ git clone &lt;https://github.com/limabrena/power-allocation-UAV-NOMA-two-users.git&gt;
</code></pre>
<p>Download ZIP file directly in my git repository:</p>
<pre><code>  &lt;https://github.com/limabrena/power-allocation-UAV-NOMA-two-users/archive/main.zip&gt;
</code></pre>
</li>
<li>
<p>Usage: </p>
<p>This application can be used as a study tool to understand the
behavior of the achievable rate by two users and the influence
of the allocation of power coefficients in a UAV-NOMA system.
The communication model presented is a base of UAV-NOMA principles and
can be expanded to several other scenarios, such as massive MIMO,
full-duplex communication, and others in order to
improve the users' rate performance.</p>
<p>The user can modify parameters and analyze the system's behavior.
Based on this, new methods can be proposed to solve trajectory problems,
power allocation, decoding order and others.</p>
<p>Example: when the Rician Factor <code>K=0</code>, fading is similar to Rayleigh's.</p>
</li>
</ul>
<hr>
<h3 id="requirement">Requirement</h3>
<p>The implementation requires Python 3.9+ to run.
The following libraries are required:</p>
<ul>
<li><code>numpy</code> </li>
<li><code>matplotlib.pyplot</code></li>
<li><code>math</code></li>
<li><code>random</code></li>
</ul>
<hr>
<h2 id="description-of-the-simulation-parameters">Description of the Simulation Parameters</h2>
<ul>
<li><code>N_mc</code> (integer) : Monte Carlo Samples.</li>
<li><code>N_users</code> (integer) : number of users (in our case, two users).</li>
<li><code>M_uav</code>(integer) : number of UAV
(in our case, single uav).</li>
<li><code>snr_dB</code> (array of integer, size[10:2:51]) : signal-to-noise ration in dB.</li>
<li><code>path_loss_exp</code> (integer) : path loss exponent.</li>
<li><code>P_los</code> (float) : total power of LOS path &amp; scattered paths.</li>
<li><code>K</code> (integer) : Rician Factor.</li>
<li><code>target_rate_primary_user</code> (float) : target rate in bits/s/Hertz of primary users. </li>
<li><code>target_rate_secondary_user</code> (float) : target rate in bits/s/Hertz of secondary users. </li>
<li><code>radius_uav</code> (float) : radius in meter of fly trajectory UAV.</li>
<li><code>radius_user</code> (float) : radius of the cell of users in meters.</li>
<li><code>distance</code>(array of float, size(N_users)) : distance between UAV and n-th user randomly calculated for each Monte Carlo sample. </li>
<li><code>ch_coeff</code> (complex number) : channel coefficients for each user generated by Rician distribution. This can be generated randomly following
using: <code>ch_coeff=np.sqrt((np.random.normal(s,sigma)**2) + 1j*(np.random.normal(0,sigma)**2))</code>.</li>
<li><code>s</code> (float) : Non-Centrality Parameter (mean) of Rician distribution, obtained by <code>s=sqrt(K/(K+1)*P_los)</code>.</li>
<li><code>sigma</code> (float) : Standard deviation of Rician distribution, obtained by <code>sigma = P_los/sqrt(2*(K+1))</code>.</li>
<li><code>h_n</code> (array of float, size(N_users)) : channel coefficients over distance effects.</li>
<li><code>channelGain</code> (array of float, size(N_users)) : channel gain <code>abs(h_n)^2</code> sorted in descending order (primary user &gt; secondary user).</li>
</ul>
<hr>
<h2 id="performance-analysis-metrics">Performance analysis metrics</h2>
<ul>
<li>
<p><code>Outage Probability:</code> the outage probability is estimated as the ratio between the number of outage events and
the total number of Monte Carlo repetitions. An outage event happens when the supported user data rates for a particular
instantaneous channel realization is less than the target data rate. </p>
</li>
<li>
<p><code>Achievable Rate:</code> the achievable rate consists of the throughput of network users, while average achievable rate
consists of the average throughput of all network users.</p>
</li>
</ul>
<hr>
<h2 id="adaptive-algorithm-description">Adaptive Algorithm description</h2>
<p>Adaptive power allocation algorithm was not implemented in the present version.</p>
<hr>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-

&#34;&#34;&#34; 
   Numerical Simulation of Power allocation in UAV-NOMA System.
   
   A Python 3.9 implementation of a model of wireless communication 
   system between an area base station and two users. 
   Initially, power allocation is employed manually.

   .. include:: ./documentation.md

&#34;&#34;&#34;

import random
import numpy as np 
from numpy import sqrt
import matplotlib.pyplot as plt
import math



# --------------- Paramenters ---------------
N_mc = 10**4  # Monte Carlo samples
N_users = 2       # Number of Users
M_uav = 1        # Number of UAVs
snr_dB = np.array(range(10, 51, 2))     
snr_linear = 10**(snr_dB/10) # SNR linear
path_loss_exp = 2


# Rician Fading
P_los =1.0 # Total power of LOS path &amp; scattered paths
K = 8 # Rician Factor (if K=0, Rayleigh fading)
s=np.sqrt(K/(K+1)*P_los) # Non-Centrality Parameter (mean)
sigma=P_los/np.sqrt(2*(K+1)) # Standard deviation

# Users&#39; Target Rate
target_rate_primary_user = 1.0  # Target rate bits/s/Hertz  primary user
target_rate_secondary_user = 0.5  # Target rate bits/s/Hertz  secondary users


powerCoeff = [0.8, 0.2] # Fixed power factor allocation NOMA for primary user and secondary user, respectively


radius_uav = 1.0 # Fly trajectory of the UAV in meters
radius_user= 2.0 # Distribution radius of users in the cell in meters.

# Initialization of some arrays
rate_us = np.zeros((N_mc,len(snr_dB)))
rate_uw = np.zeros((N_mc,len(snr_dB)))
out_probability= np.zeros((N_mc,len(snr_dB),N_users))
out_probability_system = np.zeros((N_mc,len(snr_dB)))
out_probability_secondary_user = np.zeros((N_mc,len(snr_dB)))
out_probability_primary_user = np.zeros((N_mc,len(snr_dB)))
average_rate = np.zeros((N_mc,len(snr_dB)))
instantaneous_rate_secondary = np.zeros((N_mc,len(snr_dB)))
instantaneous_rate_primary = np.zeros((N_mc,len(snr_dB)))

#------------------------------------------------------------------------------------

for mc in range(N_mc):

   def random_Position_UAV(numberUAV, radiusUAV):
      &#39;&#39;&#39; Returns a random UAV position based on 3D Cartesian coordinates.

                x_r: axis x | y_r: axis y | z_r: heigth

       `theta_r:` randomly generates an angle  

       `rho_r:` radius in meter of fly trajectory UAV


       `rho_u:` radius in meter of the area where users are distributed

        Args:

            umberUAV -- number of UAV.
            radiusUAV -- fly trajectory of the UAV in meters. 
       Return:   

            x_r, y_r, z_r -- position in the axis x, axis y and heigth of the UAV.
     &#39;&#39;&#39;
      theta_r = (np.random.rand(numberUAV,1)*(math.pi*2))
      rho_r = radiusUAV
      x_r =  (rho_r*np.cos(theta_r))
      y_r =  (rho_r*np.sin(theta_r))
      z_r = 30.0
      return x_r, y_r, z_r     

   def random_Position_Users(numberUsers, radiusUser):
      &#39;&#39;&#39; Returns a random ground users position based on 2D Cartesian coordinates. 

               x_u: axis x |  y_u: axis y | height is not considered

       `theta_u:` randomly generates an angle  

       `rho_u:` radius in meter of the area where users are distributed

        Args:

            numberUsers -- number of users.
            radiusUser -- distribution radius of users in the cell in meters.
       Return:   

            x_u, y_u -- position in the axis x and axis y of the n-th user.  

      &#39;&#39;&#39;
      theta_u = (np.random.rand(numberUsers,1))*(math.pi*2)
      rho_u = (sqrt(np.random.rand(numberUsers,1))*radiusUser)
      x_u = (rho_u*np.cos(theta_u))
      y_u = (rho_u*np.sin(theta_u))
      return x_u, y_u  

   uav_AxisX, uav_AxisY, uav_heigth = random_Position_UAV(M_uav,radius_uav)
   user_AxisX, user_AxisY = random_Position_Users(N_users,radius_user)

   # Initializing auxiliary arrays to store channel coefficients and distance between UAV and users, respectively:
   h_n = np.zeros(N_users)
   distance = np.zeros(N_users)


   def generate_Channel(s,sigma,numberUser,user_X, user_Y, uav_X, uav_Y, path_loss, uav_Z):
     &#39;&#39;&#39;Returns the sorting channel gains of the users over Rician Fading. The channel gains are sorted to identify
        the primary user and secondary user.

        `ch_coeff:` calculating channel coefficients with Random Variable Rice of mean=s and variance=sigma.

        `distance:` calculating distance between UAV and users.

        `h_n:` calculates channel coefficients based on the distance.

         `channelGain:` calculates the channel gains and sorting in descending order.

                     Primary user:  channelGain[0]   -&gt; max value

                     Secondary user:  channelGain[1] -&gt; min value    

        Args:

            s -- non-Centrality Parameter (mean).
            sigma -- standard deviation.
            numberUser -- number of user.
            user_X -- position axis x of n-th user.
            user_Y -- position axis y of n-th user.
            uav_X -- position axis x of UAV.
            uav_Y -- position axis y of UAV.
            path_loss -- path loss exponent.
            uav_z -- UAV heigth.
       Return:   

            channelGain -- sorted channel gain of the users.             
       
     &#39;&#39;&#39;
     for uu in range(numberUser):  

         ch_coeff = np.sqrt( (np.random.normal(s,sigma)**2) + 1j*(np.random.normal(0,sigma)**2) )
         distance[uu]= np.sqrt( (user_X[uu]-uav_X)**2  + (user_Y[uu]-uav_Y)**2   + uav_Z**2  )
         h_n[uu] = np.abs(ch_coeff/np.complex(sqrt(1+(distance[uu])**path_loss),0))**2

     channelGain = sorted(h_n, reverse=True)
     return channelGain  

   channelGainPrimary = np.max(generate_Channel(s,sigma,N_users,user_AxisX, user_AxisY, uav_AxisX, uav_AxisY, path_loss_exp, uav_heigth))
   channelGainSecondary = np.min(generate_Channel(s,sigma,N_users,user_AxisX, user_AxisY, uav_AxisX, uav_AxisY, path_loss_exp, uav_heigth))
      
   &#39;&#39;&#39; Initializating auxiliary arrays of: 

      Signal-to-interference-plus-noise ratio experienced by the primary user.

      Signal-to-interference-plus-noise ratio experienced by the secondary user.
   &#39;&#39;&#39;    
   sinr_primary= np.zeros((len(snr_dB))) 
   sinr_secondary = np.zeros((len(snr_dB))) 
   inst_rate_primary = np.zeros((len(snr_dB))) 
   inst_rate_secondary = np.zeros((len(snr_dB))) 
   def calculate_Instantaneous_Rate(channelPri,channelSec,snrValues,power,target_RatePri):
      &#39;&#39;&#39;Returns the instantaneous achievable rate of the primary user and secondary user for all values of SNR in dB.

         `sinr_primary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the primary user based on NOMA.

         `inst_rate_primary:` calculates instantaneous rate of the primary user based on sinr_primary.

               If the calculated instantaneous rate does not reach the rate desired by the user, OMA is used in order to guarantee 
               the Quality-of-Service requirements. 

         `sinr_secondary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the secondary user based on NOMA.

         `inst_rate_secondary:` calculates instantaneous rate of the secondary user based on sinr_secondary.
 
 
        Args:

            channelPri -- channel gain of the primary user
            channelSec -- channel gain of the secondary user.
            snrValues -- SNR values in dB.
            power --  power coefficient allocation.
            target_RatePri -- target rate of the primary user.
       Return:   
            
            inst_rate_primary -- instantaneous achievable rate of the primary user.
            inst_rate_secondary -- instantaneous achievable rate of the secondary user.   
      &#39;&#39;&#39;
      for sn in range(0,len(snrValues)):    

         sinr_primary[sn] = (snr_linear[sn]*channelPri*power[0]) / (snr_linear[sn]*channelSec*power[1]  + 1)
         inst_rate_primary[sn] = np.log(1+sinr_primary[sn]) # Instantaneous achievable rate of primary user NOMA

         if inst_rate_primary[sn] &lt; target_RatePri: 
            sinr_primary[sn] = (snr_linear[sn]*channelPri)
            inst_rate_primary[sn] = 0.5*np.log(1+sinr_primary[sn]) # Instantaneous achievable rate of primary user OMA

         sinr_secondary[sn] = (snr_linear[sn]*channelSec*power[1])
         inst_rate_secondary[sn] = np.log(1+sinr_secondary[sn]) # Instantaneous achievable rate of secondary user

      return inst_rate_primary, inst_rate_secondary

   instantaneous_rate_primary[mc,:], instantaneous_rate_secondary[mc,:] = calculate_Instantaneous_Rate(channelGainPrimary, channelGainSecondary, snr_dB, powerCoeff, target_rate_primary_user)
  
    
   for sn in range(0,len(snr_dB)):  
      # Calculating of outage probability of the system
      if (instantaneous_rate_primary[mc,sn]  &lt; target_rate_primary_user) or (instantaneous_rate_secondary[mc,sn]  &lt; target_rate_secondary_user) :
         out_probability_system[mc,sn] = 1
      else:
         out_probability_system[mc,sn] = 0      

      # Calculating of outage probability of the primary user
      if (instantaneous_rate_primary[mc,sn]  &lt; target_rate_primary_user):
         out_probability_primary_user[mc,sn] = 1
      else: 
         out_probability_primary_user[mc,sn] = 0

      # Calculating of outage probability of the secondary user
      if (instantaneous_rate_secondary[mc,sn]  &lt; target_rate_secondary_user):
         out_probability_secondary_user[mc,sn] = 1
      else: 
         out_probability_secondary_user[mc,sn] = 0

      # Calculating of average achievable rate  of the system
      average_rate[mc,sn] = (instantaneous_rate_primary[mc,sn]+instantaneous_rate_secondary[mc,sn])/2 # Average achievable rate in bits/s/Hz

#------- FIGURES --------
&#39;&#39;&#39; # To plot the figures, this comment must be removed.

# Outage Probability 

out_prob_mean = np.mean(out_probability_system, axis=0) # Outage probability of the System
out_prob_primary = np.mean(out_probability_primary_user, axis=0) # Outage probability of the Primary User
out_prob_secondary = np.mean(out_probability_secondary_user, axis=0) # Outage probability of the Secondary User


plt.semilogy(snr_dB, out_prob_mean, &#39;go-&#39;, label=&#34;Fixed Power Allocation&#34;, linewidth=2)
plt.semilogy(snr_dB, out_prob_primary, &#39;b.-&#39;, label=&#34;primary user&#34;, linewidth=1)
plt.semilogy(snr_dB, out_prob_secondary, &#39;r.-&#39;, label=&#34;secondary user&#34;, linewidth=1)

plt.xlabel(&#39;SNR (dB)&#39;)
plt.ylabel(&#39;Outage Probability&#39;)
plt.legend(loc=&#34;lower left&#34;)
plt.xlim(10,50)


#Saving outage probability values in .txt
#print(&#39;Outage probability system:&#39;, out_prob_mean, &#39;\n\nOutage probability primary user:&#39;, out_prob_primary, &#39;\n\nOutage probability secondary user:&#39;, out_prob_secondary, file=open(&#34;pa-uav-noma/outage_prob_values.txt&#34;, &#34;w&#34;))


# Average Achievable Rate 
average_rate_mean = np.mean(average_rate, axis=0) # Average achievable rate of the system
plt.figure()
plt.plot(snr_dB, average_rate_mean, &#39;r.-&#39;, label=&#34;Fixed PA&#34;, linewidth=2)
plt.xlim(10,50)
plt.xlabel(&#39;SNR (dB)&#39;)
plt.ylabel(&#39;Average achievable rate (bits/s/Hz)&#39;)
plt.legend(loc=&#34;upper left&#34;)

rate_mean_primary_user = np.mean(instantaneous_rate_primary, axis=0) # Average achievable rate of the Primary User
rate_mean_secondary_user = np.mean(instantaneous_rate_secondary, axis=0) # Average achievable rate of the Secondary User
plt.figure()
plt.plot(snr_dB, rate_mean_primary_user, &#39;b.-&#39;, label=&#34;primary user&#34;, linewidth=1)
plt.plot(snr_dB, rate_mean_secondary_user, &#39;r.-&#39;, label=&#34;secondary user&#34;, linewidth=1)
plt.xlim(10,50)
plt.xlabel(&#39;SNR (dB)&#39;)
plt.ylabel(&#39;Achievable rate (bits/s/Hz)&#39;)
plt.legend(loc=&#34;upper left&#34;)

# Saving achievable rate values in .txt
#print(&#39; Average Achievable Rate of the System:&#39;, average_rate_mean, &#39;\n\nAverage achievable rate of the Primary User:&#39;, rate_mean_primary_user, &#39;\n\nAverage achievable rate of the Secondary User:&#39;, rate_mean_secondary_user, file=open(&#34;pa-uav-noma/achievable_rate_values.txt&#34;, &#34;w&#34;))


plt.show()
&#39;&#39;&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pa-uav-noma.calculate_Instantaneous_Rate"><code class="name flex">
<span>def <span class="ident">calculate_Instantaneous_Rate</span></span>(<span>channelPri, channelSec, snrValues, power, target_RatePri)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the instantaneous achievable rate of the primary user and secondary user for all values of SNR in dB.</p>
<p><code>sinr_primary:</code> generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the primary user based on NOMA.</p>
<p><code>inst_rate_primary:</code> calculates instantaneous rate of the primary user based on sinr_primary.</p>
<pre><code>    If the calculated instantaneous rate does not reach the rate desired by the user, OMA is used in order to guarantee 
    the Quality-of-Service requirements.
</code></pre>
<p><code>sinr_secondary:</code> generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the secondary user based on NOMA.</p>
<p><code>inst_rate_secondary:</code> calculates instantaneous rate of the secondary user based on sinr_secondary.</p>
<p>Args:</p>
<pre><code> channelPri -- channel gain of the primary user
 channelSec -- channel gain of the secondary user.
 snrValues -- SNR values in dB.
 power --  power coefficient allocation.
 target_RatePri -- target rate of the primary user.
</code></pre>
<p>Return:
</p>
<pre><code> inst_rate_primary -- instantaneous achievable rate of the primary user.
 inst_rate_secondary -- instantaneous achievable rate of the secondary user.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_Instantaneous_Rate(channelPri,channelSec,snrValues,power,target_RatePri):
   &#39;&#39;&#39;Returns the instantaneous achievable rate of the primary user and secondary user for all values of SNR in dB.

      `sinr_primary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the primary user based on NOMA.

      `inst_rate_primary:` calculates instantaneous rate of the primary user based on sinr_primary.

            If the calculated instantaneous rate does not reach the rate desired by the user, OMA is used in order to guarantee 
            the Quality-of-Service requirements. 

      `sinr_secondary:` generates the Signal-to-interference-plus-noise ratio (SINR) experienced by the secondary user based on NOMA.

      `inst_rate_secondary:` calculates instantaneous rate of the secondary user based on sinr_secondary.


     Args:

         channelPri -- channel gain of the primary user
         channelSec -- channel gain of the secondary user.
         snrValues -- SNR values in dB.
         power --  power coefficient allocation.
         target_RatePri -- target rate of the primary user.
    Return:   
         
         inst_rate_primary -- instantaneous achievable rate of the primary user.
         inst_rate_secondary -- instantaneous achievable rate of the secondary user.   
   &#39;&#39;&#39;
   for sn in range(0,len(snrValues)):    

      sinr_primary[sn] = (snr_linear[sn]*channelPri*power[0]) / (snr_linear[sn]*channelSec*power[1]  + 1)
      inst_rate_primary[sn] = np.log(1+sinr_primary[sn]) # Instantaneous achievable rate of primary user NOMA

      if inst_rate_primary[sn] &lt; target_RatePri: 
         sinr_primary[sn] = (snr_linear[sn]*channelPri)
         inst_rate_primary[sn] = 0.5*np.log(1+sinr_primary[sn]) # Instantaneous achievable rate of primary user OMA

      sinr_secondary[sn] = (snr_linear[sn]*channelSec*power[1])
      inst_rate_secondary[sn] = np.log(1+sinr_secondary[sn]) # Instantaneous achievable rate of secondary user

   return inst_rate_primary, inst_rate_secondary</code></pre>
</details>
</dd>
<dt id="pa-uav-noma.generate_Channel"><code class="name flex">
<span>def <span class="ident">generate_Channel</span></span>(<span>s, sigma, numberUser, user_X, user_Y, uav_X, uav_Y, path_loss, uav_Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sorting channel gains of the users over Rician Fading. The channel gains are sorted to identify
the primary user and secondary user.</p>
<p><code>ch_coeff:</code> calculating channel coefficients with Random Variable Rice of mean=s and variance=sigma.</p>
<p><code>distance:</code> calculating distance between UAV and users.</p>
<p><code>h_n:</code> calculates channel coefficients based on the distance.</p>
<p><code>channelGain:</code> calculates the channel gains and sorting in descending order.</p>
<pre><code>          Primary user:  channelGain[0]   -&gt; max value

          Secondary user:  channelGain[1] -&gt; min value
</code></pre>
<p>Args:</p>
<pre><code> s -- non-Centrality Parameter (mean).
 sigma -- standard deviation.
 numberUser -- number of user.
 user_X -- position axis x of n-th user.
 user_Y -- position axis y of n-th user.
 uav_X -- position axis x of UAV.
 uav_Y -- position axis y of UAV.
 path_loss -- path loss exponent.
 uav_z -- UAV heigth.
</code></pre>
<p>Return:
</p>
<pre><code> channelGain -- sorted channel gain of the users.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_Channel(s,sigma,numberUser,user_X, user_Y, uav_X, uav_Y, path_loss, uav_Z):
  &#39;&#39;&#39;Returns the sorting channel gains of the users over Rician Fading. The channel gains are sorted to identify
     the primary user and secondary user.

     `ch_coeff:` calculating channel coefficients with Random Variable Rice of mean=s and variance=sigma.

     `distance:` calculating distance between UAV and users.

     `h_n:` calculates channel coefficients based on the distance.

      `channelGain:` calculates the channel gains and sorting in descending order.

                  Primary user:  channelGain[0]   -&gt; max value

                  Secondary user:  channelGain[1] -&gt; min value    

     Args:

         s -- non-Centrality Parameter (mean).
         sigma -- standard deviation.
         numberUser -- number of user.
         user_X -- position axis x of n-th user.
         user_Y -- position axis y of n-th user.
         uav_X -- position axis x of UAV.
         uav_Y -- position axis y of UAV.
         path_loss -- path loss exponent.
         uav_z -- UAV heigth.
    Return:   

         channelGain -- sorted channel gain of the users.             
    
  &#39;&#39;&#39;
  for uu in range(numberUser):  

      ch_coeff = np.sqrt( (np.random.normal(s,sigma)**2) + 1j*(np.random.normal(0,sigma)**2) )
      distance[uu]= np.sqrt( (user_X[uu]-uav_X)**2  + (user_Y[uu]-uav_Y)**2   + uav_Z**2  )
      h_n[uu] = np.abs(ch_coeff/np.complex(sqrt(1+(distance[uu])**path_loss),0))**2

  channelGain = sorted(h_n, reverse=True)
  return channelGain  </code></pre>
</details>
</dd>
<dt id="pa-uav-noma.random_Position_UAV"><code class="name flex">
<span>def <span class="ident">random_Position_UAV</span></span>(<span>numberUAV, radiusUAV)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a random UAV position based on 3D Cartesian coordinates.</p>
<pre><code>     x_r: axis x | y_r: axis y | z_r: heigth
</code></pre>
<p><code>theta_r:</code> randomly generates an angle
</p>
<p><code>rho_r:</code> radius in meter of fly trajectory UAV</p>
<p><code>rho_u:</code> radius in meter of the area where users are distributed</p>
<p>Args:</p>
<pre><code> umberUAV -- number of UAV.
 radiusUAV -- fly trajectory of the UAV in meters.
</code></pre>
<p>Return:
</p>
<pre><code> x_r, y_r, z_r -- position in the axis x, axis y and heigth of the UAV.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_Position_UAV(numberUAV, radiusUAV):
   &#39;&#39;&#39; Returns a random UAV position based on 3D Cartesian coordinates.

             x_r: axis x | y_r: axis y | z_r: heigth

    `theta_r:` randomly generates an angle  

    `rho_r:` radius in meter of fly trajectory UAV


    `rho_u:` radius in meter of the area where users are distributed

     Args:

         umberUAV -- number of UAV.
         radiusUAV -- fly trajectory of the UAV in meters. 
    Return:   

         x_r, y_r, z_r -- position in the axis x, axis y and heigth of the UAV.
  &#39;&#39;&#39;
   theta_r = (np.random.rand(numberUAV,1)*(math.pi*2))
   rho_r = radiusUAV
   x_r =  (rho_r*np.cos(theta_r))
   y_r =  (rho_r*np.sin(theta_r))
   z_r = 30.0
   return x_r, y_r, z_r     </code></pre>
</details>
</dd>
<dt id="pa-uav-noma.random_Position_Users"><code class="name flex">
<span>def <span class="ident">random_Position_Users</span></span>(<span>numberUsers, radiusUser)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a random ground users position based on 2D Cartesian coordinates. </p>
<pre><code>    x_u: axis x |  y_u: axis y | height is not considered
</code></pre>
<p><code>theta_u:</code> randomly generates an angle
</p>
<p><code>rho_u:</code> radius in meter of the area where users are distributed</p>
<p>Args:</p>
<pre><code> numberUsers -- number of users.
 radiusUser -- distribution radius of users in the cell in meters.
</code></pre>
<p>Return:
</p>
<pre><code> x_u, y_u -- position in the axis x and axis y of the n-th user.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_Position_Users(numberUsers, radiusUser):
   &#39;&#39;&#39; Returns a random ground users position based on 2D Cartesian coordinates. 

            x_u: axis x |  y_u: axis y | height is not considered

    `theta_u:` randomly generates an angle  

    `rho_u:` radius in meter of the area where users are distributed

     Args:

         numberUsers -- number of users.
         radiusUser -- distribution radius of users in the cell in meters.
    Return:   

         x_u, y_u -- position in the axis x and axis y of the n-th user.  

   &#39;&#39;&#39;
   theta_u = (np.random.rand(numberUsers,1))*(math.pi*2)
   rho_u = (sqrt(np.random.rand(numberUsers,1))*radiusUser)
   x_u = (rho_u*np.cos(theta_u))
   y_u = (rho_u*np.sin(theta_u))
   return x_u, y_u  </code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#how-can-use-this-application">How can use this application?</a></li>
<li><a href="#requirement">Requirement</a></li>
<li><a href="#description-of-the-simulation-parameters">Description of the Simulation Parameters</a></li>
<li><a href="#performance-analysis-metrics">Performance analysis metrics</a></li>
<li><a href="#adaptive-algorithm-description">Adaptive Algorithm description</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pa-uav-noma.calculate_Instantaneous_Rate" href="#pa-uav-noma.calculate_Instantaneous_Rate">calculate_Instantaneous_Rate</a></code></li>
<li><code><a title="pa-uav-noma.generate_Channel" href="#pa-uav-noma.generate_Channel">generate_Channel</a></code></li>
<li><code><a title="pa-uav-noma.random_Position_UAV" href="#pa-uav-noma.random_Position_UAV">random_Position_UAV</a></code></li>
<li><code><a title="pa-uav-noma.random_Position_Users" href="#pa-uav-noma.random_Position_Users">random_Position_Users</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>